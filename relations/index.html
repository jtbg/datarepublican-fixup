---
layout: default
title: People Relations (BETA)
---

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<script src="svg-pan-zoom.min.js"></script>

<!-- JSZip for reading zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<script src="murmurHash3.js"></script>

<style>

  .shidden { display: none; }
  .toggle-btn {
    background: none;
    border: none;
    color: #2563EB;
    cursor: pointer;
    padding: 0;
  }
  .loading-spinner {
    vertical-align: middle;
  }
  #graph-container {
    width: 100%;
    height: 80vh;      /* or calc(100vh - someOffset) */
    position: relative;
    overflow: hidden;  /* if you like; up to you */
  }
  #legend {
    display: flex;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 0.5rem;
  }
  
  /* D3 Graph Styles */
  .node rect {
    fill: #F3F4F6;
    stroke: #94A3B8;
    stroke-width: 1px;
    filter: drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.1));
  }
  .node.root rect {
    stroke: #2563EB;
    stroke-width: 3px;
    fill: #EFF6FF;
  }
  .node text {
    pointer-events: none;
  }
  .link {
    fill: none;
    stroke: #CBD5E1;
    stroke-width: 2px;
    filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.05));
  }
  .arrow-path {
    fill: #CBD5E1;
  }
  .label-bg {
    fill: #F3F4F6;
    stroke: white;
    stroke-width: 2px;
    filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.1));
  }
  .link-label {
    fill: #475569;
    font-size: 12px;
    text-anchor: middle;
    pointer-events: none;
  }
  .legend-item {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    color: white;
    margin-right: 4px;
    margin-bottom: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
  .legend-item.disabled {
    opacity: 0.5;
  }
</style>

<!-- 
=========================
======== SEARCH UI ======
=========================

This container is displayed in "Search Mode" (no ?subject= in the URL),
letting the user enter a name, see results, and click to load GraphViz mode.
-->

<div id="searchMode" class="mb-4 shidden">
<h1 class="mb-1">People &amp; relationships lookup</h1>
<p class="text-sm mb-3">
  Search for a name or phrase. We'll do an inclusive search (all tokens must appear).
  Each matching subject is displayed along with a quick description. Click on a name to load its relationship graph.
</p>

<div id="searchFormWrapper" class="mb-4">
  <form id="searchForm" class="flex flex-wrap gap-2 items-end">
    <div>
      <label for="searchBox" class="text-sm font-bold mb-1">Name/Keyword(s)</label><br/>
      <input type="text" id="searchBox" class="border border-gray-200 rounded p-2 w-full" placeholder="E.g. 'aaron' or '14th Dalai Lama'"/>
    </div>

    <button type="submit" id="searchButton" class="p-2 border border-gray-200 rounded font-bold text-sm">
      <span class="button-text">Search</span>
      <img src="../assets/images/loading-white.svg" class="loading-spinner" style="display:none;width:16px;height:16px" alt="Loading..."/>
    </button>

    <div class="relative -top-1">
      <input type="checkbox" id="prefixCheck"/>
      <label for="prefixCheck" class="text-sm">Use prefix matching</label>
    </div>

    <span id="statusMessage" class="text-sm"></span>
  </form>
</div>

<div id="resultsContainer" class="flex flex-col gap-2"></div>
<div id="resultsStatus" class="mt-2 text-sm"></div>
</div>

<!-- 
===============================
======== GRAPHVIZ UI =========
===============================

This container is displayed in "GraphViz Mode" (when ?subject= is in the URL, or after user clicks on a result).
It shows the generated graph and a legend, plus a button to go back to the search mode.
-->

<div id="graphMode" class="shidden">
<button id="backToSearch" class="toggle-btn frameless !mb-2">&larr; Return to search</button>

<div id="graphExplanation" class="mb-3">
  <h1 id="graphTitle" class="mb-1">Relationship Graph</h1>
  <p class="text-sm mb-2" id="graphInstructions">
    Below is a visualization of our selected subject's relationships, color-coded by category.  
    <strong>Click any color</strong> in the legend below to toggle that category on/off. The graph will re-render automatically.  
    Click "Download SVG" to get an offline copy of the image.
  </p>
</div>

<!-- Legend for edge categories -->
<div id="legend"></div>

<!-- A spot to show short summary about the root subject from bullets.csv -->
<div id="rootSummary" class="mb-4 p-2 md:px-4 md:pt-3 border rounded text-sm bg-white"></div>

<!-- Where the graph renders -->
<div id="graph-container" class="border rounded flex items-center justify-center bg-white">
  <svg id="graph" width="100%" height="100%">
    <!-- Arrow marker definition for edges -->
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
        markerWidth="6" markerHeight="6" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" class="arrow-path" />
      </marker>
    </defs>
    <g id="graph-content"></g>
  </svg>
  <div id="loading-indicator" class="absolute">
    <img src="../assets/images/loading.svg" class="loading-spinner" style="width:32px;height:32px" alt="Loading...">
  </div>
</div>

<!-- Download button -->
<div class="mt-2 text-right">
  <button id="downloadBtn" class="toggle-btn" style="display: none;">Download SVG</button>
</div>
</div>


<script>
/***************************************
* GLOBALS
***************************************/
let allReverseIndex = new Map();      // token -> array of lineIDs (with ranges)
let allSubjects = [];                 // lines from subjects.csv (index = line-1)
let allBullets = new Map();           // subject -> { bullet_point1, bullet_point2 }
let searchInProgress = false;
let searchCanceled = false;
let hasInitialDataLoaded = false;

// For Graph Mode
const NUM_PARTITIONS = 47;           
let categoryColors = {               
  "FAMILY": "#E11D48",
  "WORK": "#2563EB",
  "POLITICAL": "#9333EA",
  "LEGAL": "#DC2626",
  "MEDIA": "#EA580C",
  "EDUCATION": "#4ADE80",
  "HISTORICAL": "#D97706",
  "SOCIAL": "#14B8A6",
  "OTHER": "#6B7280",
  "UNKNOWN": "#6B7280"
};

// D3 Graph variables
let width, height;
let simulation = null;
let zoom = null;
let nodeElements = null;
let linkElements = null;
let labelElements = null;

// We store all graph edges in memory so toggling categories is easy:
let globalNodesMap = new Map();  // subject -> bullet info
let globalAllEdges = [];         // all edges (including duplicates filtered out)
let globalActiveCategories = new Set(); // which categories are currently on display

// Force simulation parameters
const forceParams = {
  linkDistance: 400,
  charge: -3000,
  collisionRadius: 200,
  bounds: {
    left: 100,
    right: 100,
    top: 100,
    bottom: 100
  }
};

/***************************************
* ON LOAD
***************************************/
$(document).ready(async function() {
  // Check if we have a ?subject= param
  const urlParams = new URLSearchParams(window.location.search);
  const subj = urlParams.get('subject');

  // Show/hide respective modes
  if (subj) {
    $('#graphMode').removeClass('shidden');
  } else {
    $('#searchMode').removeClass('shidden');
  }

  // Start loading data in background
  await loadInitialData();

  // If we have ?subject=, go straight to GraphViz mode after data loads
  if (subj) {
    renderGraphForSubject(subj);
  }

  // Otherwise, remain in search mode, but if the user typed any text in ?search= param, do that:
  const searchParam = urlParams.get('search');
  if (!subj && searchParam) {
    $('#searchBox').val(searchParam);
    $('#searchForm').trigger('submit');
  }
});


/***************************************
* Load initial data: reverse_index, subjects.csv, bullets.csv
***************************************/
async function loadInitialData() {
  if (hasInitialDataLoaded) return;
  $('#statusMessage').text('Loading data...');

  try {
    // Show spinner
    $('#searchButton .button-text').hide();
    $('#searchButton .loading-spinner').show();
    $('#searchButton').prop('disabled', true);

    // 1) Load reverse_index.txt
    await loadReverseIndex("reverse_index.txt");

    // 2) Load subjects.csv (from subjects.csv.zip)
    await loadSubjectsCSV("subjects.csv.zip", "subjects.csv");

    // 3) Load bullets.csv (from bullets.csv.zip)
    await loadBulletsCSV("bullets.csv.zip", "bullets.csv");

    hasInitialDataLoaded = true;
    $('#statusMessage').empty();
  } catch (err) {
    console.error(err);
    $('#statusMessage').text("Error: " + err);
  } finally {
    // Hide spinner
    $('#searchButton .loading-spinner').hide();
    $('#searchButton .button-text').show();
    $('#searchButton').prop('disabled', false);
  }
}

async function loadReverseIndex(txtUrl) {
  // If it's zipped, do fetch -> JSZip -> read string. 
  // For demo, assume it's just "reverse_index.txt".
  const resp = await fetch(txtUrl);
  if (!resp.ok) throw new Error(`Could not fetch ${txtUrl}`);
  const text = await resp.text();

  // parse lines like "aaron:75-110,6194,8048,13186,20098,34603"
  const lines = text.split(/\r?\n/);
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    const parts = line.split(':');
    if (parts.length !== 2) continue;
    const token = parts[0];
    const ranges = parts[1].split(',');

    let lineIDs = [];
    for (let r of ranges) {
      if (r.includes('-')) {
        const [start, end] = r.split('-').map(x=>parseInt(x,10));
        for (let i=start; i<=end; i++) {
          lineIDs.push(i);
        }
      } else {
        let val = parseInt(r, 10);
        if (!isNaN(val)) {
          lineIDs.push(val);
        }
      }
    }
    if (!allReverseIndex.has(token)) {
      allReverseIndex.set(token, []);
    }
    allReverseIndex.get(token).push(...lineIDs);
  }
}

async function loadSubjectsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });
  allSubjects = parsed.data; 
}

async function loadBulletsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });

  for (let row of parsed.data) {
    const s = row['subject']?.trim() ?? '';
    if (!s) continue;
    allBullets.set(s, {
      bullet_point1: row['bullet_point1'] || '',
      bullet_point2: row['bullet_point2'] || ''
    });
  }
}


/***************************************
* SEARCH FORM
***************************************/
$('#searchForm').on('submit', async function(e) {
  e.preventDefault();
  if (searchInProgress) {
    // If in progress, let user cancel
    searchCanceled = true;
    return;
  }
  searchCanceled = false;
  searchInProgress = true;

  // clear old results
  $('#resultsContainer').empty();
  $('#resultsStatus').empty();

  // show spinner
  $('#searchButton .button-text').text("Stop");
  $('#searchBox').prop('disabled', true);

  try {
    await doSearch();
  } catch (err) {
    console.error(err);
    $('#resultsContainer').html(`<div class="p-2 text-center text-sm text-red-500">Error: ${err}</div>`);
  }

  // restore
  searchInProgress = false;
  $('#searchButton .button-text').text("Search");
  $('#searchBox').prop('disabled', false);
});


async function doSearch() {
  const rawInput = $('#searchBox').val().toLowerCase().trim();
  if (!rawInput) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No input provided.</div>');
    return;
  }

  // update URL param ?search= 
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  newUrl.searchParams.set('search', rawInput);
  window.history.pushState({}, '', newUrl);

  // tokenize
  let tokens = tokenizeInput(rawInput);

  // intersect sets
  let finalLineSet = null;
  for (let t of tokens) {
    if (searchCanceled) break;

    let linesForT = new Set();
    // exact matches
    if (allReverseIndex.has(t)) {
      for (let ln of allReverseIndex.get(t)) {
        linesForT.add(ln);
      }
    }
    // prefix if box is checked
    if ($('#prefixCheck').is(':checked') && t.length >= 4) {
      // find anything that starts with t
      for (let [kw, lines] of allReverseIndex.entries()) {
        if (kw.startsWith(t) && kw !== t) {
          for (let ln of lines) {
            linesForT.add(ln);
          }
        }
      }
    }

    // intersect
    if (finalLineSet === null) {
      finalLineSet = linesForT;
    } else {
      let tmp = new Set();
      for (let x of finalLineSet) {
        if (linesForT.has(x)) tmp.add(x);
      }
      finalLineSet = tmp;
    }
    if (!finalLineSet.size) break;
  }

  if (!finalLineSet || !finalLineSet.size) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No matches found.</div>');
    return;
  }

  let sortedLines = Array.from(finalLineSet).sort((a,b)=>a-b);
  let limit = 100;
  let displayed = 0;

  for (let ln of sortedLines) {
    if (searchCanceled) break;
    if (displayed >= limit) break;

    let idx = ln - 1;
    if (idx >= 0 && idx < allSubjects.length) {
      let row = allSubjects[idx];
      let subject = row['subject'] || '';
      let desc = row['bullet_point1'] || '';
      $('#resultsContainer').append(renderSearchResult(subject, desc));
      displayed++;
    }
  }

  if (displayed > 0) {
    let extra = searchCanceled ? ' (stopped)' : (displayed === limit ? ' (limit)' : '');
    $('#resultsStatus').text(`Showing ${displayed}${extra} results`);
  } else {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No results found.</div>');
  }
}

function tokenizeInput(txt) {
  // remove non-alphanumeric except for ' and "
  txt = txt.replace(/[^\w\s"']+/g, ' ');
  return txt.split(/\s+/).filter(Boolean);
}

function renderSearchResult(subject, desc) {
  const safeSubject = escapeHtml(subject);
  const safeDesc = escapeHtml(desc);

  let $div = $(`
    <div class="group border border-gray-200 hover:border-gray-400 bg-white rounded p-2 md:px-4 leading-tight">
      <strong class="text-navy group-hover:text-blue text-sm">${safeSubject}</strong><br/>
      <span class="text-[13px]">${safeDesc}</span>
    </div>
  `);

  $div.css('cursor','pointer').on('click', function() {
    window.location.href = '?subject=' + encodeURIComponent(subject);
  });

  return $div;
}


/***************************************
* BACK TO SEARCH
***************************************/
$('#backToSearch').on('click', function() {
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  window.history.pushState({}, '', newUrl);
  window.location.reload();
});


/***************************************
* GRAPH MODE
***************************************/
async function renderGraphForSubject(subjectName) {
  // Show loading indicator
  $('#loading-indicator').show();
  $('#graph-content').empty();

  // Set the search param in the URL
  const newUrl = new URL(window.location);
  newUrl.searchParams.set('subject', subjectName);
  window.history.pushState({}, '', newUrl);

  // Put subject name in title
  $('#graphTitle').text(subjectName);

  // Summarize from bullets.csv if found
  let bulletInfo = allBullets.get(subjectName) || {};
  let b1 = bulletInfo.bullet_point1 || "";
  let b2 = bulletInfo.bullet_point2 || "";
  let summaryHtml = `<p class="mb-2"><strong>${escapeHtml(subjectName)}</strong></p>`;
  if (b1) summaryHtml += `<p class="mb-2">${escapeHtml(b1)}</p>`;
  if (b2) summaryHtml += `<p>${escapeHtml(b2)}</p>`;
  if (!b1 && !b2) {
    summaryHtml += `<p class="text-sm text-gray-600">(No extended info available.)</p>`;
  }
  $('#rootSummary').html(summaryHtml);

  // Clear globals for new subject
  globalNodesMap.clear();
  globalAllEdges = [];
  globalActiveCategories.clear();

  // Initialize D3 graph
  initializeD3Graph();

  // Add the root node
  addNodeIfNeeded(globalNodesMap, subjectName);

  // figure out which partition
  const partitionIdx = partitionIndex(subjectName);
  let pStr = partitionIdx.toString().padStart(2,'0');
  const relationsZip = `relations_${pStr}.zip`;

  try {
    // Show loading status
    $('#graphInstructions').html(`
      <div class="flex items-center gap-2">
        <img src="../assets/images/loading.svg" class="loading-spinner" style="width:16px;height:16px" alt="Loading...">
        <span>Loading relationship data for ${escapeHtml(subjectName)}...</span>
      </div>
    `);

    const resp = await fetch(relationsZip);
    if (!resp.ok) {
      throw new Error(`Unable to fetch ${relationsZip}`);
    }
    const buffer = await resp.arrayBuffer();
    const z = await JSZip.loadAsync(buffer);

    // Update loading status
    $('#graphInstructions').html(`
      <div class="flex items-center gap-2">
        <img src="../assets/images/loading.svg" class="loading-spinner" style="width:16px;height:16px" alt="Loading...">
        <span>Parsing relationship data...</span>
      </div>
    `);

    // parse relations.csv, relations_reverse.csv, intergraph_edges.csv
    const relationsCsv     = await getZipText(z, 'relations.csv');
    const revCsv           = await getZipText(z, 'relations_reverse.csv');
    const interCsv         = await getZipText(z, 'intergraph_edges.csv');

    const parsedRelations  = Papa.parse(relationsCsv,     { header:true, skipEmptyLines:true }).data;
    const parsedReverse    = Papa.parse(revCsv,           { header:true, skipEmptyLines:true }).data;
    const parsedIntergraph = Papa.parse(interCsv,         { header:true, skipEmptyLines:true }).data;

    // Update loading status
    $('#graphInstructions').html(`
      <div class="flex items-center gap-2">
        <img src="../assets/images/loading.svg" class="loading-spinner" style="width:16px;height:16px" alt="Loading...">
        <span>Building relationship graph...</span>
      </div>
    `);

    let edgesSet = new Set(); // to ensure no duplicates

    // 1) Forward edges
    for (let row of parsedRelations) {
      let s = row.subject?.trim() || "";
      if (s !== subjectName) continue;
      let o = (row.object || "").trim();
      if (!o) continue;

      addNodeIfNeeded(globalNodesMap, o);
      let c = row.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, o, (row.label||""), c, color);
    }

    // 2) Reverse edges
    for (let revRow of parsedReverse) {
      let obj = revRow.object?.trim() || "";
      if (obj !== subjectName) continue;

      let s = revRow.subject?.trim() || "";
      if (!s) continue;

      let symmetrical = parseInt(revRow.is_symmetrical,10) === 1;
      if (symmetrical) {
        // skip if forward set had the mirror
        let hasMirror = parsedRelations.some(rel => {
          return (rel.subject?.trim() === subjectName && rel.object?.trim() === s);
        });
        if (hasMirror) continue;
      }
      addNodeIfNeeded(globalNodesMap, s);
      let c = revRow.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, subjectName, (revRow.label||""), c, color);
    }

    // 3) Intergraph edges
    const potentialEdges = [];
    for (let iRow of parsedIntergraph) {
      let rp = iRow.root_person?.trim() || "";
      if (rp !== subjectName) continue;

      let s = iRow.subject?.trim() || "";
      let o = iRow.object?.trim() || "";
      if (!s || !o) continue;

      if (globalNodesMap.has(s) && globalNodesMap.has(o)) {
        potentialEdges.push({
          from: s,
          to: o,
          label: iRow.label || "",
          symmetrical: parseInt(iRow.is_symmetrical,10)===1,
          category: iRow.category?.trim() || "UNKNOWN"
        });
      }
    }
    // Filter symmetrical duplicates
    let finalInterEdges = [];
    for (let pe of potentialEdges) {
      let swapped = potentialEdges.find(e => {
        return (e.from === pe.to && e.to === pe.from && e.symmetrical === true && pe.symmetrical === true);
      });
      if (swapped && pe.from > pe.to) {
        // skip
        continue;
      }
      finalInterEdges.push(pe);
    }
    // Add them
    for (let pe of finalInterEdges) {
      let c = pe.category;
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, pe.from, pe.to, pe.label, c, color);
    }

    // Initialize active categories
    let uniqueCats = new Set(globalAllEdges.map(e => e.category));
    for (let c of uniqueCats) {
      globalActiveCategories.add(c);
    }

    // Render the legend
    renderLegend([...uniqueCats]);

    // Update loading status
    $('#graphInstructions').html(`
      <div class="flex items-center gap-2">
        <img src="../assets/images/loading.svg" class="loading-spinner" style="width:16px;height:16px" alt="Loading...">
        <span>Rendering graph with ${globalNodesMap.size} nodes and ${globalAllEdges.length} connections...</span>
      </div>
    `);

    // Prepare data for D3
    const nodes = [];
    const edges = [];
    
    // Add nodes
    for (let [subject, bulletInfo] of globalNodesMap.entries()) {
      nodes.push({
        id: subject,
        bulletInfo: bulletInfo
      });
    }
    
    // Add edges
    for (let edge of globalAllEdges) {
      edges.push({
        source: edge.from,
        target: edge.to,
        from: edge.from,
        to: edge.to,
        label: edge.label,
        category: edge.category,
        color: edge.color
      });
    }
    
    // Render the D3 graph
    renderD3Graph(subjectName, nodes, edges);

    // Restore instructions
    setTimeout(() => {
      $('#graphInstructions').html(`
        Below is a visualization of our selected subject's relationships, color-coded by category.  
        <strong>Click any color</strong> in the legend below to toggle that category on/off. The graph will re-render automatically.  
        Click "Download SVG" to get an offline copy of the image.
      `);
    }, 1000);

  } catch (err) {
    console.error(err);
    $('#graph-container').html(
      `<div class="p-2 text-center text-sm text-red-500">Error loading relationships: ${err}</div>`
    );
    $('#graphInstructions').html(`
      <div class="text-red-500">Error: ${escapeHtml(err.message)}</div>
    `);
  }
}

// Build & render the DOT from globalNodesMap + filtered edges

// A function to ensure node exists
function addNodeIfNeeded(map, subject) {
  if (!map.has(subject)) {
    let bullet = allBullets.get(subject) || { bullet_point1:'', bullet_point2:'' };
    map.set(subject, bullet);
  }
}

// Deduplicate edges
function addEdge(edgesSet, edgesArray, from, to, label, category, color) {
  let key = `${from}||${to}||${category}||${label}`;
  if (edgesSet.has(key)) {
    return; // skip duplicates
  }
  edgesSet.add(key);
  edgesArray.push({ from, to, label, category, color });
}

// Partition
function partitionIndex(subj) {
  const h = murmurHash3.x86.hash32(subj);
  return h % NUM_PARTITIONS;
}

async function getZipText(zipObj, filename) {
  if (!zipObj.file(filename)) throw new Error(`Missing ${filename} in zip.`);
  return await zipObj.file(filename).async('string');
}


/***************************************

function buildDotSource(rootSubject, nodesMap, edges) {
  let dot = `digraph G {
rankdir="TB";
node [ shape=box, style="filled", fillcolor="#F3F4F6", color="#94A3B8", fontname="Arial", fontsize=13 ];
edge [ fontname="Arial", color="#DADBE7", penwidth=2, fontsize=11 ];
`;

  for (let [subj, bulletData] of nodesMap.entries()) {
    let p1Wrapped = insertLineBreaks(bulletData.bullet_point1 || "");
    let p2Wrapped = insertLineBreaks(bulletData.bullet_point2 || "");
    let subjWrapped = insertLineBreaks(subj);

    // HTML-like label
    let label = `<<table border="0" cellborder="0" cellpadding="2" cellspacing="0">
      <tr><td align="left"><b>${subjWrapped}</b></td></tr>
      ${ p1Wrapped ? `<tr><td align="left"><font point-size="10">${p1Wrapped}</font></td></tr>` : '' }
      ${ p2Wrapped ? `<tr><td align="left"><font point-size="10">${p2Wrapped}</font></td></tr>` : '' }
    </table>>`;

    if (subj === rootSubject) {
      dot += `"${subj}" [ color="#2563EB", penwidth=3, label=${label} ];\n`;
    } else {
      dot += `"${subj}" [ label=${label} ];\n`;
    }
  }

  for (let e of edges) {
    dot += `"${e.from}" -> "${e.to}" [ label="${escapeHtml(e.label)}", color="${e.color}" ];\n`;
  }

  dot += `}\n`;
  return dot;
}

function renderDot(dotSrc) {
  $('#graph-container').empty();
  let viz = new Viz();

  viz.renderSVGElement(dotSrc)
    .then(svgEl => {
      // let it fill the container
      svgEl.setAttribute('width', '100%');
      svgEl.setAttribute('height', '100%');
      svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      $('#graph-container').append(svgEl);

      // enable pan/zoom
      if (panZoomInstance) {
        panZoomInstance.destroy();
      }
      panZoomInstance = svgPanZoom(svgEl, {
        zoomEnabled: true,
        controlIconsEnabled: true,
        fit: true,
        center: true
      });
      // Force another fit + center so it uses max space
      panZoomInstance.resize();
      panZoomInstance.fit();
      panZoomInstance.center();

      // show download button
      $('#downloadBtn').show();
    })
    .catch(err => {
      console.error(err);
      $('#graph-container').html(`<div class="p-2 text-center text-sm text-red-500">Error generating graph: ${err}</div>`);
    });
}


/***************************************
* LEGEND & CATEGORY TOGGLING
***************************************/
function renderLegend(categories) {
  let html = '';
  categories.sort(); // optional: sort them alphabetically
  for (let c of categories) {
    let color = categoryColors[c] || categoryColors["UNKNOWN"];
    html += `<div class="legend-item" data-cat="${c}" style="background-color: ${color};">${c}</div>`;
  }
  $('#legend').html(html);

  // Attach click handler
  $('#legend .legend-item').on('click', function() {
    let cat = $(this).data('cat');
    toggleCategory(cat);
    $(this).toggleClass('disabled', !globalActiveCategories.has(cat));
  });
}

// Toggle a category in/out of the active set
function toggleCategory(cat) {
  if (globalActiveCategories.has(cat)) {
    globalActiveCategories.delete(cat);
  } else {
    globalActiveCategories.add(cat);
  }
  
  // Filter edges based on active categories
  const activeEdges = globalAllEdges.filter(e => globalActiveCategories.has(e.category));
  
  // Update edge visibility
  linkElements.attr('visibility', d => 
    globalActiveCategories.has(d.category) ? 'visible' : 'hidden'
  );
  
  // Update label visibility
  labelElements.attr('visibility', d => 
    globalActiveCategories.has(d.category) ? 'visible' : 'hidden'
  );
}


/***************************************
* DOWNLOAD SVG
***************************************/
$('#downloadBtn').on('click', function() {
  const svgEl = document.querySelector('#graph');
  if (!svgEl) {
    alert('No SVG to download');
    return;
  }
  
  // Create a clone of the SVG to modify for download
  const clonedSvg = svgEl.cloneNode(true);
  
  // Set explicit width and height
  clonedSvg.setAttribute('width', width);
  clonedSvg.setAttribute('height', height);
  
  // Reset the transform to ensure the graph is centered
  const content = clonedSvg.querySelector('#graph-content');
  if (content) {
    content.setAttribute('transform', `translate(${width/2}, ${height/2})`);
  }
  
  // Convert to string
  const svgData = new XMLSerializer().serializeToString(clonedSvg);
  const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  let link = document.createElement('a');
  link.href = url;
  link.download = 'relation_graph.svg';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
});


/***************************************
* HELPER
***************************************/
function escapeHtml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

/***************************************
* D3 GRAPH RENDERING
***************************************/
function initializeD3Graph() {
  // Get container dimensions
  const container = document.getElementById('graph-container');
  width = container.clientWidth;
  height = container.clientHeight;
  
  // Initialize zoom behavior
  zoom = d3.zoom()
    .scaleExtent([0.1, 2])
    .on('zoom', (event) => {
      d3.select('#graph-content').attr('transform', event.transform);
    });
  
  // Apply zoom behavior to SVG
  d3.select('#graph')
    .call(zoom)
    .on('dblclick.zoom', null); // Disable double-click zoom
    
  // Reset zoom and pan
  resetZoom();
  
  // Show loading indicator
  $('#loading-indicator').show();
}

function resetZoom() {
  d3.select('#graph').call(
    zoom.transform,
    d3.zoomIdentity.translate(width/2, height/2)
  );
}

function renderD3Graph(rootSubject, nodes, edges) {
  // Clear previous graph
  d3.select('#graph-content').selectAll('*').remove();
  
  // Hide loading indicator when rendering starts
  $('#loading-indicator').hide();
  
  // Create the graph content group
  const g = d3.select('#graph-content');
  
  // Create links
  linkElements = g.append('g')
    .attr('class', 'links')
    .selectAll('path')
    .data(edges)
    .join('path')
    .attr('class', 'link')
    .attr('stroke', d => d.color)
    .attr('stroke-width', 2)
    .attr('marker-end', 'url(#arrow)');
  
  // Create nodes
  nodeElements = g.append('g')
    .attr('class', 'nodes')
    .selectAll('g')
    .data(nodes)
    .join('g')
    .attr('class', d => d.id === rootSubject ? 'node root' : 'node')
    .attr('data-id', d => d.id)
    .call(d3.drag()
      .on('start', dragStarted)
      .on('drag', dragged)
      .on('end', dragEnded)
    );
  
  // Add rectangles to nodes
  nodeElements.append('rect')
    .attr('rx', 4)
    .attr('ry', 4)
    .attr('width', d => getNodeWidth(d))
    .attr('height', d => getNodeHeight(d))
    .style('cursor', 'grab');
  
  // Add text to nodes
  nodeElements.each(function(d) {
    const node = d3.select(this);
    const bulletInfo = d.bulletInfo;
    const padding = 10;
    let y = padding;
    
    // Add subject name
    node.append('text')
      .attr('x', padding)
      .attr('y', y + 15)
      .attr('font-weight', 'bold')
      .attr('font-size', '14px')
      .text(d.id);
    y += 25;
    
    // Add bullet point 1 if available
    if (bulletInfo.bullet_point1) {
      const wrappedText = wrapText(bulletInfo.bullet_point1, 30);
      wrappedText.forEach(line => {
        node.append('text')
          .attr('x', padding)
          .attr('y', y + 12)
          .attr('font-size', '12px')
          .text(line);
        y += 18;
      });
    }
    
    // Add bullet point 2 if available
    if (bulletInfo.bullet_point2) {
      y += 5; // Add a little extra space
      const wrappedText = wrapText(bulletInfo.bullet_point2, 30);
      wrappedText.forEach(line => {
        node.append('text')
          .attr('x', padding)
          .attr('y', y + 12)
          .attr('font-size', '12px')
          .text(line);
        y += 18;
      });
    }
  });
  
  // Create edge labels
  const labelGroup = g.append('g').attr('class', 'label-group');
  labelElements = labelGroup.selectAll('g')
    .data(edges)
    .join('g')
    .attr('class', 'link-label-group');
  
  // Add background pill for labels
  labelElements.append('rect')
    .attr('rx', 12)
    .attr('ry', 12)
    .attr('class', 'label-bg')
    .style('cursor', 'pointer')
    .on('mouseover', function(event, d) {
      d3.select(this).attr('fill', d.color);
      d3.select(this.parentNode).select('.link-label').attr('fill', 'white');
      linkElements.filter(l => l === d).attr('stroke-width', 4);
    })
    .on('mouseout', function() {
      d3.select(this).attr('fill', '#F3F4F6');
      d3.select(this.parentNode).select('.link-label').attr('fill', '#475569');
      linkElements.attr('stroke-width', 2);
    });
  
  // Add text labels with wrapping
  labelElements.each(function(d) {
    const labelGroup = d3.select(this);
    const label = d.label || "";
    
    // Skip empty labels
    if (!label.trim()) {
      labelGroup.append('text')
        .attr('class', 'link-label')
        .text("");
      return;
    }
    
    // Wrap text to max 20 characters per line
    const wrappedText = wrapText(label, 20);
    
    // Add each line of text
    wrappedText.forEach((line, i) => {
      labelGroup.append('text')
        .attr('class', 'link-label')
        .attr('dy', (i - (wrappedText.length - 1) / 2) * 16)
        .text(line);
    });
  });
  
  // Add hover effects to nodes
  nodeElements.on('mouseover', function(event, d) {
    // Highlight this node
    d3.select(this).select('rect')
      .attr('stroke-width', 3)
      .attr('stroke', '#2563EB');
    
    // Highlight connected edges and nodes
    linkElements.each(function(link) {
      if (link.from === d.id || link.to === d.id) {
        d3.select(this)
          .attr('stroke-width', 4)
          .attr('stroke', link.color);
        
        // Highlight connected node
        const connectedId = link.from === d.id ? link.to : link.from;
        nodeElements.filter(n => n.id === connectedId)
          .select('rect')
          .attr('stroke-width', 2)
          .attr('stroke', link.color);
      }
    });
    
    // Highlight related labels
    labelElements.each(function(label) {
      if (label.from === d.id || label.to === d.id) {
        d3.select(this).select('.label-bg')
          .attr('fill', label.color);
        d3.select(this).select('.link-label')
          .attr('fill', 'white');
      }
    });
  })
  .on('mouseout', function() {
    // Reset node styles
    nodeElements.select('rect')
      .attr('stroke-width', d => d.id === rootSubject ? 3 : 1)
      .attr('stroke', d => d.id === rootSubject ? '#2563EB' : '#94A3B8');
    
    // Reset edge styles
    linkElements
      .attr('stroke-width', 2)
      .attr('stroke', d => d.color);
    
    // Reset label styles
    labelElements.select('.label-bg')
      .attr('fill', '#F3F4F6');
    labelElements.select('.link-label')
      .attr('fill', '#475569');
  });
  
  // Start the simulation
  simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(edges)
      .id(d => d.id)
      .distance(d => {
        // Adjust link distance based on node sizes
        const sourceNode = nodes.find(n => n.id === d.from);
        const targetNode = nodes.find(n => n.id === d.to);
        if (!sourceNode || !targetNode) return forceParams.linkDistance;
        
        const sourceSize = Math.sqrt(getNodeWidth(sourceNode) * getNodeHeight(sourceNode));
        const targetSize = Math.sqrt(getNodeWidth(targetNode) * getNodeHeight(targetNode));
        
        // Base distance on node sizes plus padding
        return (sourceSize + targetSize) / 2 + forceParams.linkDistance;
      }))
    .force('charge', d3.forceManyBody()
      .strength(d => {
        // Adjust repulsion based on node size
        const nodeSize = Math.sqrt(getNodeWidth(d) * getNodeHeight(d));
        return forceParams.charge * (nodeSize / 200);
      })
      .distanceMin(150)
      .distanceMax(2000))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('x', d3.forceX(width / 2).strength(0.05))
    .force('y', d3.forceY(height / 2).strength(0.05))
    .force('collision', d3.forceCollide().radius(d => {
      // Make collision radius based on node size plus padding
      const nodeWidth = getNodeWidth(d);
      const nodeHeight = getNodeHeight(d);
      return Math.sqrt(nodeWidth * nodeHeight) / 1.2 + 50;
    }).strength(1))
    .alpha(0.6)
    .alphaDecay(0.01) // Slower decay for more time to find optimal positions
    .velocityDecay(0.4) // Lower value to allow nodes to move more freely
    .on('tick', ticked);
  
  // Enable download button
  $('#downloadBtn').show();
  
  // Auto-zoom to fit all nodes after simulation stabilizes
  setTimeout(() => {
    zoomToFitAll();
  }, 2000);
}

// Function to zoom to fit all nodes
function zoomToFitAll() {
  if (!nodeElements || !nodeElements.size()) return;
  
  // Get bounding box of all nodes
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  nodeElements.each(function(d) {
    const nodeWidth = getNodeWidth(d);
    const nodeHeight = getNodeHeight(d);
    
    minX = Math.min(minX, d.x - nodeWidth/2);
    minY = Math.min(minY, d.y - nodeHeight/2);
    maxX = Math.max(maxX, d.x + nodeWidth/2);
    maxY = Math.max(maxY, d.y + nodeHeight/2);
  });
  
  // Add padding
  const padding = 50;
  minX -= padding;
  minY -= padding;
  maxX += padding;
  maxY += padding;
  
  const graphWidth = maxX - minX;
  const graphHeight = maxY - minY;
  
  // Calculate scale to fit
  const scale = Math.min(
    width / graphWidth,
    height / graphHeight,
    1.5 // Max scale
  );
  
  // Calculate center point
  const centerX = minX + graphWidth/2;
  const centerY = minY + graphHeight/2;
  
  // Apply zoom transform
  d3.select('#graph').transition()
    .duration(750)
    .call(
      zoom.transform,
      d3.zoomIdentity
        .translate(width/2, height/2)
        .scale(scale)
        .translate(-centerX, -centerY)
    );
}

// Call the overlap prevention after the simulation has stabilized
simulation.on('end', preventLabelOverlaps);

// Update the ticked function to occasionally prevent overlaps
function ticked() {
  // Update node positions
  nodeElements.attr('transform', d => {
    // Constrain to bounds
    d.x = Math.max(forceParams.bounds.left, Math.min(width - forceParams.bounds.right, d.x));
    d.y = Math.max(forceParams.bounds.top, Math.min(height - forceParams.bounds.bottom, d.y));
    return `translate(${d.x - getNodeWidth(d) / 2}, ${d.y - getNodeHeight(d) / 2})`;
  });
  
  // Update link paths
  linkElements.attr('d', d => {
    const sourceNode = nodeElements.filter(n => n.id === d.from).datum();
    const targetNode = nodeElements.filter(n => n.id === d.to).datum();
    
    if (!sourceNode || !targetNode) return '';
    
    const sourceWidth = getNodeWidth(sourceNode);
    const sourceHeight = getNodeHeight(sourceNode);
    const targetWidth = getNodeWidth(targetNode);
    const targetHeight = getNodeHeight(targetNode);
    
    // Calculate source and target points on the edges of the rectangles
    const sourceX = sourceNode.x;
    const sourceY = sourceNode.y;
    const targetX = targetNode.x;
    const targetY = targetNode.y;
    
    // Find intersection points with rectangles
    const sourcePoint = findIntersectionPoint(
      sourceX, sourceY, targetX, targetY,
      sourceX - sourceWidth/2, sourceY - sourceHeight/2,
      sourceWidth, sourceHeight
    );
    
    const targetPoint = findIntersectionPoint(
      targetX, targetY, sourceX, sourceY,
      targetX - targetWidth/2, targetY - targetHeight/2,
      targetWidth, targetHeight
    );
    
    if (!sourcePoint || !targetPoint) return '';
    
    // Create orthogonal (right-angled) paths
    // Determine if the path should go horizontally first or vertically first
    const dx = Math.abs(targetPoint.x - sourcePoint.x);
    const dy = Math.abs(targetPoint.y - sourcePoint.y);
    
    // If nodes are more separated horizontally than vertically, go horizontal first
    if (dx > dy) {
      const midX = sourcePoint.x + (targetPoint.x - sourcePoint.x) / 2;
      return `M${sourcePoint.x},${sourcePoint.y} 
              L${midX},${sourcePoint.y} 
              L${midX},${targetPoint.y} 
              L${targetPoint.x},${targetPoint.y}`;
    } else {
      // Otherwise go vertical first
      const midY = sourcePoint.y + (targetPoint.y - sourcePoint.y) / 2;
      return `M${sourcePoint.x},${sourcePoint.y} 
              L${sourcePoint.x},${midY} 
              L${targetPoint.x},${midY} 
              L${targetPoint.x},${targetPoint.y}`;
    }
  });
  
  // Update label positions with collision detection
  labelElements.attr('transform', function(d) {
    const path = linkElements.filter(l => l === d).node();
    if (!path) return '';
    
    const pathLength = path.getTotalLength();
    if (isNaN(pathLength) || pathLength === 0) return '';
    
    // Position label at the midpoint of the path
    const midPoint = path.getPointAtLength(pathLength / 2);
    
    // Store the midpoint for collision detection
    d.labelX = midPoint.x;
    d.labelY = midPoint.y;
    
    return `translate(${midPoint.x}, ${midPoint.y})`;
  });
  
  // Update label background sizes
  labelElements.each(function(d) {
    const labelTexts = d3.select(this).selectAll('.link-label');
    if (!labelTexts.size()) return;
    
    // Calculate bounding box that encompasses all text elements
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    labelTexts.each(function() {
      const bbox = this.getBBox();
      minX = Math.min(minX, bbox.x);
      minY = Math.min(minY, bbox.y);
      maxX = Math.max(maxX, bbox.x + bbox.width);
      maxY = Math.max(maxY, bbox.y + bbox.height);
    });
    
    // Add padding
    const padding = { x: 10, y: 6 };
    
    d3.select(this).select('.label-bg')
      .attr('x', minX - padding.x)
      .attr('y', minY - padding.y)
      .attr('width', maxX - minX + padding.x * 2)
      .attr('height', maxY - minY + padding.y * 2);
  });
  
  // Occasionally prevent label overlaps during simulation
  if (Math.random() < 0.1) {
    preventLabelOverlaps();
  }
}

function dragStarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
  d3.select(this).style('cursor', 'grabbing');
}

function dragged(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}

function dragEnded(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
  d3.select(this).style('cursor', 'grab');
}

function getNodeWidth(d) {
  // Calculate width based on text content
  const minWidth = 200;
  const textLength = d.id.length;
  const bulletLength1 = d.bulletInfo?.bullet_point1?.length || 0;
  const bulletLength2 = d.bulletInfo?.bullet_point2?.length || 0;
  const maxTextLength = Math.max(textLength, bulletLength1 / 5, bulletLength2 / 5);
  return Math.max(minWidth, maxTextLength * 7);
}

function getNodeHeight(d) {
  // Calculate height based on text content
  const baseHeight = 50; // Minimum height
  const bulletInfo = d.bulletInfo;
  let additionalHeight = 0;
  
  if (bulletInfo.bullet_point1) {
    const lines1 = Math.ceil(bulletInfo.bullet_point1.length / 30);
    additionalHeight += lines1 * 18;
  }
  
  if (bulletInfo.bullet_point2) {
    const lines2 = Math.ceil(bulletInfo.bullet_point2.length / 30);
    additionalHeight += lines2 * 18 + 5; // +5 for spacing
  }
  
  return baseHeight + additionalHeight;
}

function wrapText(text, maxCharsPerLine) {
  if (!text) return [];
  
  const words = text.split(' ');
  const lines = [];
  let currentLine = '';
  
  words.forEach(word => {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    if (testLine.length <= maxCharsPerLine) {
      currentLine = testLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  });
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}

function findIntersectionPoint(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight) {
  // Calculate rectangle corners
  const corners = [
    { x: rectX, y: rectY }, // top-left
    { x: rectX + rectWidth, y: rectY }, // top-right
    { x: rectX + rectWidth, y: rectY + rectHeight }, // bottom-right
    { x: rectX, y: rectY + rectHeight } // bottom-left
  ];
  
  // Check intersection with each edge of the rectangle
  const edges = [
    [corners[0], corners[1]], // top
    [corners[1], corners[2]], // right
    [corners[2], corners[3]], // bottom
    [corners[3], corners[0]]  // left
  ];
  
  for (const [p1, p2] of edges) {
    const intersection = lineIntersection(x1, y1, x2, y2, p1.x, p1.y, p2.x, p2.y);
    if (intersection) {
      return intersection;
    }
  }
  
  // If no intersection found, return center of rectangle
  return { x: rectX + rectWidth / 2, y: rectY + rectHeight / 2 };
}

function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
  // Calculate determinants
  const den = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  if (den === 0) return null; // Lines are parallel
  
  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / den;
  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / den;
  
  // Check if intersection is on both line segments
  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null;
  
  // Calculate intersection point
  const x = x1 + ua * (x2 - x1);
  const y = y1 + ua * (y2 - y1);
  
  return { x, y };
}

// After positioning all labels, adjust positions to prevent overlaps
function preventLabelOverlaps() {
  const labels = labelElements.nodes();
  const labelData = labelElements.data();
  
  // Create a quadtree for efficient collision detection
  const quadtree = d3.quadtree()
    .x(d => d.labelX)
    .y(d => d.labelY)
    .addAll(labelData);
  
  // For each label, check for overlaps and adjust position
  labelElements.each(function(d, i) {
    const labelGroup = d3.select(this);
    const labelBg = labelGroup.select('.label-bg').node();
    if (!labelBg) return;
    
    const bbox = labelBg.getBBox();
    const padding = 10; // Extra space between labels
    
    // Define the bounds of this label
    const x0 = d.labelX + bbox.x - padding;
    const y0 = d.labelY + bbox.y - padding;
    const x1 = d.labelX + bbox.x + bbox.width + padding;
    const y1 = d.labelY + bbox.y + bbox.height + padding;
    
    // Find nearby labels that might overlap
    quadtree.visit((node, x1q, y1q, x2q, y2q) => {
      if (!node.length) {
        do {
          const d2 = node.data;
          if (d2 && d2 !== d && labelOverlap(d, d2, bbox, padding)) {
            // Adjust position to avoid overlap
            adjustLabelPosition(d, d2);
          }
        } while (node = node.next);
      }
      return x1q > x1 || y1q > y1 || x2q < x0 || y2q < y0;
    });
    
    // Update the transform with the potentially adjusted position
    labelGroup.attr('transform', `translate(${d.labelX}, ${d.labelY})`);
  });
}

// Check if two labels overlap
function labelOverlap(d1, d2, bbox, padding) {
  // Find the index of d2 in the data array
  const d2Index = labelElements.data().indexOf(d2);
  const labelGroup2 = d3.select(labelElements.nodes()[d2Index]);
  const labelBg2 = labelGroup2.select('.label-bg').node();
  if (!labelBg2) return false;
  
  const bbox2 = labelBg2.getBBox();
  
  // Check for rectangle overlap
  return !(
    d1.labelX + bbox.x + bbox.width + padding < d2.labelX + bbox2.x ||
    d1.labelX + bbox.x > d2.labelX + bbox2.x + bbox2.width + padding ||
    d1.labelY + bbox.y + bbox.height + padding < d2.labelY + bbox2.y ||
    d1.labelY + bbox.y > d2.labelY + bbox2.y + bbox2.height + padding
  );
}

// Adjust label position to avoid overlap
function adjustLabelPosition(d1, d2) {
  // Calculate vector between labels
  const dx = d2.labelX - d1.labelX;
  const dy = d2.labelY - d1.labelY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < 1) {
    // If labels are at the same position, move in a random direction
    const angle = Math.random() * Math.PI * 2;
    d1.labelX += Math.cos(angle) * 30;
    d1.labelY += Math.sin(angle) * 30;
  } else {
    // Move away from the other label
    const moveDistance = 30; // Distance to move
    d1.labelX -= (dx / distance) * moveDistance;
    d1.labelY -= (dy / distance) * moveDistance;
  }
}
</script>
