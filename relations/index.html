---
layout: default
title: People Relations (BETA)
---

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- Viz.js (core + full render) -->
<!-- <script src="viz.js"></script>
<script src="full.render.js"></script> -->

<!-- Cytoscape.js for modern graph visualization -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<!-- <script src="svg-pan-zoom.min.js"></script> -->

<!-- JSZip for reading zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<script src="murmurHash3.js"></script>

<style>

  .shidden { display: none; }
  .toggle-btn {
    background: none;
    border: none;
    color: #2563EB;
    cursor: pointer;
    padding: 0;
  }
  .loading-spinner {
    vertical-align: middle;
  }
  #graph-container {
    width: 100%;
    height: 80vh;      /* or calc(100vh - someOffset) */
    position: relative;
    overflow: hidden;  /* if you like; up to you */
  }
  #legend {
    display: flex;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 0.5rem;
  }
  .legend-item {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .legend-item.disabled {
    opacity: 0.5;
  }
  /* Category colors */
  .legend-FAMILY { background-color: #E11D48; }
  .legend-WORK { background-color: #2563EB; }
  .legend-POLITICAL { background-color: #9333EA; }
  .legend-LEGAL { background-color: #DC2626; }
  .legend-MEDIA { background-color: #EA580C; }
  .legend-EDUCATION { background-color: #4ADE80; }
  .legend-HISTORICAL { background-color: #D97706; }
  .legend-SOCIAL { background-color: #14B8A6; }
  .legend-OTHER { background-color: #6B7280; }
  .legend-UNKNOWN { background-color: #6B7280; }
  
  /* Cytoscape specific styles */
  #cy-controls {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    z-index: 10;
  }
  
  .cy-button {
    width: 40px;
    height: 40px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .cy-button:hover {
    background: #f5f5f5;
  }
  
  /* Node tooltip styles */
  .cy-tooltip {
    position: absolute;
    z-index: 1000;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    pointer-events: none;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s;
    line-height: 1.4;
  }

  /* Node styling */
  #cy node {
    text-wrap: wrap;
    text-max-width: 200px;
    text-overflow: ellipsis;
    border-width: 1px;
    font-size: 12px;
    min-width: 50px;
    min-height: 50px;
  }

  #loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
  }
</style>

<!-- 
=========================
======== SEARCH UI ======
=========================

This container is displayed in "Search Mode" (no ?subject= in the URL),
letting the user enter a name, see results, and click to load GraphViz mode.
-->

<div id="searchMode" class="mb-4 shidden">
<h1 class="mb-1">People &amp; relationships lookup</h1>
<p class="text-sm mb-3">
  Search for a name or phrase. We'll do an inclusive search (all tokens must appear).
  Each matching subject is displayed along with a quick description. Click on a name to load its relationship graph.
</p>

<div id="searchFormWrapper" class="mb-4">
  <form id="searchForm" class="flex flex-wrap gap-2 items-end">
    <div>
      <label for="searchBox" class="text-sm font-bold mb-1">Name/Keyword(s)</label><br/>
      <input type="text" id="searchBox" class="border border-gray-200 rounded p-2 w-full" placeholder="E.g. 'aaron' or '14th Dalai Lama'"/>
    </div>

    <button type="submit" id="searchButton" class="p-2 border border-gray-200 rounded font-bold text-sm">
      <span class="button-text">Search</span>
      <img src="../assets/images/loading-white.svg" class="loading-spinner" style="display:none;width:16px;height:16px" alt="Loading..."/>
    </button>

    <div class="relative -top-1">
      <input type="checkbox" id="prefixCheck"/>
      <label for="prefixCheck" class="text-sm">Use prefix matching</label>
    </div>

    <span id="statusMessage" class="text-sm"></span>
  </form>
</div>

<div id="resultsContainer" class="flex flex-col gap-2"></div>
<div id="resultsStatus" class="mt-2 text-sm"></div>
</div>

<!-- 
===============================
======== GRAPHVIZ UI =========
===============================

This container is displayed in "GraphViz Mode" (when ?subject= is in the URL, or after user clicks on a result).
It shows the generated graph and a legend, plus a button to go back to the search mode.
-->

<div id="graphMode" class="shidden">
<button id="backToSearch" class="toggle-btn frameless !mb-2">&larr; Return to search</button>

<div id="graphExplanation" class="mb-3">
  <h1 id="graphTitle" class="mb-1">Relationship Graph</h1>
  <p class="text-sm mb-2" id="graphInstructions">
    Below is a visualization of our selected subject's relationships, color-coded by category.  
    <strong>Click any color</strong> in the legend below to toggle that category on/off. The graph will re-render automatically.  
    Click "Download PNG" to get an offline copy of the image.
  </p>
</div>

<!-- Legend for edge categories -->
<div id="legend"></div>

<!-- A spot to show short summary about the root subject from bullets.csv -->
<div id="rootSummary" class="mb-4 p-2 md:px-4 md:pt-3 border rounded text-sm bg-white"></div>

<!-- Where the graph renders -->
<div id="graph-container" class="border rounded flex items-center justify-center bg-white">
  <div id="cy" style="width: 100%; height: 100%;"></div>
  <div id="cy-controls">
    <button class="cy-button" id="zoom-in">+</button>
    <button class="cy-button" id="zoom-out">-</button>
    <button class="cy-button" id="reset-view">‚ü≤</button>
  </div>
  <div class="cy-tooltip"></div>
  <div id="loading-indicator">
    <img src="../assets/images/loading.svg" class="loading-spinner" style="width:32px;height:32px" alt="Loading...">
  </div>
</div>

<!-- Download button -->
<div class="mt-2 text-right">
  <button id="downloadBtn" class="toggle-btn" style="display: none;">Download PNG</button>
</div>
</div>


<script>
/***************************************
* GLOBALS
***************************************/
let allReverseIndex = new Map();      // token -> array of lineIDs (with ranges)
let allSubjects = [];                 // lines from subjects.csv (index = line-1)
let allBullets = new Map();           // subject -> { bullet_point1, bullet_point2 }
let searchInProgress = false;
let searchCanceled = false;
let hasInitialDataLoaded = false;

// For Graph Mode
const NUM_PARTITIONS = 47;           
let categoryColors = {               
  "FAMILY": "#E11D48",
  "WORK": "#2563EB",
  "POLITICAL": "#9333EA",
  "LEGAL": "#DC2626",
  "MEDIA": "#EA580C",
  "EDUCATION": "#4ADE80",
  "HISTORICAL": "#D97706",
  "SOCIAL": "#14B8A6",
  "OTHER": "#6B7280",
  "UNKNOWN": "#6B7280"
};

let panZoomInstance = null;

// We store all graph edges in memory so toggling categories is easy:
let globalNodesMap = new Map();  // subject -> bullet info
let globalAllEdges = [];         // all edges (including duplicates filtered out)
let globalActiveCategories = new Set(); // which categories are currently on display


/***************************************
* ON LOAD
***************************************/
$(document).ready(async function() {
  // Check if we have a ?subject= param
  const urlParams = new URLSearchParams(window.location.search);
  const subj = urlParams.get('subject');

  // Show/hide respective modes
  if (subj) {
    $('#graphMode').removeClass('shidden');
  } else {
    $('#searchMode').removeClass('shidden');
  }

  // Start loading data in background
  await loadInitialData();

  // If we have ?subject=, go straight to GraphViz mode after data loads
  if (subj) {
    renderGraphForSubject(subj);
  }

  // Otherwise, remain in search mode, but if the user typed any text in ?search= param, do that:
  const searchParam = urlParams.get('search');
  if (!subj && searchParam) {
    $('#searchBox').val(searchParam);
    $('#searchForm').trigger('submit');
  }
});


/***************************************
* Load initial data: reverse_index, subjects.csv, bullets.csv
***************************************/
async function loadInitialData() {
  if (hasInitialDataLoaded) return;
  $('#statusMessage').text('Loading data...');

  try {
    // Show spinner
    $('#searchButton .button-text').hide();
    $('#searchButton .loading-spinner').show();
    $('#searchButton').prop('disabled', true);

    // 1) Load reverse_index.txt
    await loadReverseIndex("reverse_index.txt");

    // 2) Load subjects.csv (from subjects.csv.zip)
    await loadSubjectsCSV("subjects.csv.zip", "subjects.csv");

    // 3) Load bullets.csv (from bullets.csv.zip)
    await loadBulletsCSV("bullets.csv.zip", "bullets.csv");

    hasInitialDataLoaded = true;
    $('#statusMessage').empty();
  } catch (err) {
    console.error(err);
    $('#statusMessage').text("Error: " + err);
  } finally {
    // Hide spinner
    $('#searchButton .loading-spinner').hide();
    $('#searchButton .button-text').show();
    $('#searchButton').prop('disabled', false);
  }
}

async function loadReverseIndex(txtUrl) {
  // If it's zipped, do fetch -> JSZip -> read string. 
  // For demo, assume it's just "reverse_index.txt".
  const resp = await fetch(txtUrl);
  if (!resp.ok) throw new Error(`Could not fetch ${txtUrl}`);
  const text = await resp.text();

  // parse lines like "aaron:75-110,6194,8048,13186,20098,34603"
  const lines = text.split(/\r?\n/);
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    const parts = line.split(':');
    if (parts.length !== 2) continue;
    const token = parts[0];
    const ranges = parts[1].split(',');

    let lineIDs = [];
    for (let r of ranges) {
      if (r.includes('-')) {
        const [start, end] = r.split('-').map(x=>parseInt(x,10));
        for (let i=start; i<=end; i++) {
          lineIDs.push(i);
        }
      } else {
        let val = parseInt(r, 10);
        if (!isNaN(val)) {
          lineIDs.push(val);
        }
      }
    }
    if (!allReverseIndex.has(token)) {
      allReverseIndex.set(token, []);
    }
    allReverseIndex.get(token).push(...lineIDs);
  }
}

async function loadSubjectsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });
  allSubjects = parsed.data; 
}

async function loadBulletsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });

  for (let row of parsed.data) {
    const s = row['subject']?.trim() ?? '';
    if (!s) continue;
    allBullets.set(s, {
      bullet_point1: row['bullet_point1'] || '',
      bullet_point2: row['bullet_point2'] || ''
    });
  }
}


/***************************************
* SEARCH FORM
***************************************/
$('#searchForm').on('submit', async function(e) {
  e.preventDefault();
  if (searchInProgress) {
    // If in progress, let user cancel
    searchCanceled = true;
    return;
  }
  searchCanceled = false;
  searchInProgress = true;

  // clear old results
  $('#resultsContainer').empty();
  $('#resultsStatus').empty();

  // show spinner
  $('#searchButton .button-text').text("Stop");
  $('#searchBox').prop('disabled', true);

  try {
    await doSearch();
  } catch (err) {
    console.error(err);
    $('#resultsContainer').html(`<div class="p-2 text-center text-sm text-red-500">Error: ${err}</div>`);
  }

  // restore
  searchInProgress = false;
  $('#searchButton .button-text').text("Search");
  $('#searchBox').prop('disabled', false);
});


async function doSearch() {
  const rawInput = $('#searchBox').val().toLowerCase().trim();
  if (!rawInput) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No input provided.</div>');
    return;
  }

  // update URL param ?search= 
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  newUrl.searchParams.set('search', rawInput);
  window.history.pushState({}, '', newUrl);

  // tokenize
  let tokens = tokenizeInput(rawInput);

  // intersect sets
  let finalLineSet = null;
  for (let t of tokens) {
    if (searchCanceled) break;

    let linesForT = new Set();
    // exact matches
    if (allReverseIndex.has(t)) {
      for (let ln of allReverseIndex.get(t)) {
        linesForT.add(ln);
      }
    }
    // prefix if box is checked
    if ($('#prefixCheck').is(':checked') && t.length >= 4) {
      // find anything that starts with t
      for (let [kw, lines] of allReverseIndex.entries()) {
        if (kw.startsWith(t) && kw !== t) {
          for (let ln of lines) {
            linesForT.add(ln);
          }
        }
      }
    }

    // intersect
    if (finalLineSet === null) {
      finalLineSet = linesForT;
    } else {
      let tmp = new Set();
      for (let x of finalLineSet) {
        if (linesForT.has(x)) tmp.add(x);
      }
      finalLineSet = tmp;
    }
    if (!finalLineSet.size) break;
  }

  if (!finalLineSet || !finalLineSet.size) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No matches found.</div>');
    return;
  }

  let sortedLines = Array.from(finalLineSet).sort((a,b)=>a-b);
  let limit = 100;
  let displayed = 0;

  for (let ln of sortedLines) {
    if (searchCanceled) break;
    if (displayed >= limit) break;

    let idx = ln - 1;
    if (idx >= 0 && idx < allSubjects.length) {
      let row = allSubjects[idx];
      let subject = row['subject'] || '';
      let desc = row['bullet_point1'] || '';
      $('#resultsContainer').append(renderSearchResult(subject, desc));
      displayed++;
    }
  }

  if (displayed > 0) {
    let extra = searchCanceled ? ' (stopped)' : (displayed === limit ? ' (limit)' : '');
    $('#resultsStatus').text(`Showing ${displayed}${extra} results`);
  } else {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No results found.</div>');
  }
}

function tokenizeInput(txt) {
  // remove non-alphanumeric except for ' and "
  txt = txt.replace(/[^\w\s"']+/g, ' ');
  return txt.split(/\s+/).filter(Boolean);
}

function renderSearchResult(subject, desc) {
  const safeSubject = escapeHtml(subject);
  const safeDesc = escapeHtml(desc);

  let $div = $(`
    <div class="group border border-gray-200 hover:border-gray-400 bg-white rounded p-2 md:px-4 leading-tight">
      <strong class="text-navy group-hover:text-blue text-sm">${safeSubject}</strong><br/>
      <span class="text-[13px]">${safeDesc}</span>
    </div>
  `);

  $div.css('cursor','pointer').on('click', function() {
    window.location.href = '?subject=' + encodeURIComponent(subject);
  });

  return $div;
}


/***************************************
* BACK TO SEARCH
***************************************/
$('#backToSearch').on('click', function() {
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  window.history.pushState({}, '', newUrl);
  window.location.reload();
});


/***************************************
* GRAPH MODE
***************************************/
async function renderGraphForSubject(subjectName) {
  // Show spinner in #graph-container
  $('#loading-indicator').show();
  $('#cy').empty();
  
  // Make sure download button is hidden while loading
  $('#downloadBtn').hide();

  // Set the search param in the URL
  const newUrl = new URL(window.location);
  newUrl.searchParams.set('subject', subjectName);
  window.history.pushState({}, '', newUrl);

  // Put subject name in title
  $('#graphTitle').text(subjectName);

  // Summarize from bullets.csv if found
  let bulletInfo = allBullets.get(subjectName) || {};
  let b1 = bulletInfo.bullet_point1 || "";
  let b2 = bulletInfo.bullet_point2 || "";
  let summaryHtml = `<p class="mb-2"><strong>${escapeHtml(subjectName)}</strong></p>`;
  if (b1) summaryHtml += `<p class="mb-2">${escapeHtml(b1)}</p>`;
  if (b2) summaryHtml += `<p>${escapeHtml(b2)}</p>`;
  if (!b1 && !b2) {
    summaryHtml += `<p class="text-sm text-gray-600">(No extended info available.)</p>`;
  }
  $('#rootSummary').html(summaryHtml);

  // Clear globals for new subject
  globalNodesMap.clear();
  globalAllEdges = [];
  globalActiveCategories.clear();

  // Add the root node
  addNodeIfNeeded(globalNodesMap, subjectName);

  // figure out which partition
  const partitionIdx = partitionIndex(subjectName);
  let pStr = partitionIdx.toString().padStart(2,'0');
  const relationsZip = `relations_${pStr}.zip`;

  try {
    const resp = await fetch(relationsZip);
    if (!resp.ok) {
      throw new Error(`Unable to fetch ${relationsZip}`);
    }
    const buffer = await resp.arrayBuffer();
    const z = await JSZip.loadAsync(buffer);

    // parse relations.csv, relations_reverse.csv, intergraph_edges.csv
    const relationsCsv     = await getZipText(z, 'relations.csv');
    const revCsv           = await getZipText(z, 'relations_reverse.csv');
    const interCsv         = await getZipText(z, 'intergraph_edges.csv');

    const parsedRelations  = Papa.parse(relationsCsv,     { header:true, skipEmptyLines:true }).data;
    const parsedReverse    = Papa.parse(revCsv,           { header:true, skipEmptyLines:true }).data;
    const parsedIntergraph = Papa.parse(interCsv,         { header:true, skipEmptyLines:true }).data;

    let edgesSet = new Set(); // to ensure no duplicates

    // 1) Forward edges
    for (let row of parsedRelations) {
      let s = row.subject?.trim() || "";
      if (s !== subjectName) continue;
      let o = (row.object || "").trim();
      if (!o) continue;

      addNodeIfNeeded(globalNodesMap, o);
      let c = row.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, o, (row.label||""), c, color);
    }

    // 2) Reverse edges
    for (let revRow of parsedReverse) {
      let obj = revRow.object?.trim() || "";
      if (obj !== subjectName) continue;

      let s = revRow.subject?.trim() || "";
      if (!s) continue;

      let symmetrical = parseInt(revRow.is_symmetrical,10) === 1;
      if (symmetrical) {
        // skip if forward set had the mirror
        let hasMirror = parsedRelations.some(rel => {
          return (rel.subject?.trim() === subjectName && rel.object?.trim() === s);
        });
        if (hasMirror) continue;
      }
      addNodeIfNeeded(globalNodesMap, s);
      let c = revRow.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, subjectName, (revRow.label||""), c, color);
    }

    // 3) Intergraph edges
    const potentialEdges = [];
    for (let iRow of parsedIntergraph) {
      let rp = iRow.root_person?.trim() || "";
      if (rp !== subjectName) continue;

      let s = iRow.subject?.trim() || "";
      let o = iRow.object?.trim() || "";
      if (!s || !o) continue;

      if (globalNodesMap.has(s) && globalNodesMap.has(o)) {
        potentialEdges.push({
          from: s,
          to: o,
          label: iRow.label || "",
          symmetrical: parseInt(iRow.is_symmetrical,10)===1,
          category: iRow.category?.trim() || "UNKNOWN"
        });
      }
    }
    // Filter symmetrical duplicates
    let finalInterEdges = [];
    for (let pe of potentialEdges) {
      let swapped = potentialEdges.find(e => {
        return (e.from === pe.to && e.to === pe.from && e.symmetrical === true && pe.symmetrical === true);
      });
      if (swapped && pe.from > pe.to) {
        // skip
        continue;
      }
      finalInterEdges.push(pe);
    }
    // Add them
    for (let pe of finalInterEdges) {
      let c = pe.category;
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, pe.from, pe.to, pe.label, c, color);
    }

    // Initialize active categories
    let uniqueCats = new Set(globalAllEdges.map(e => e.category));
    for (let c of uniqueCats) {
      globalActiveCategories.add(c);
    }

    // Render the legend
    renderLegend([...uniqueCats]);

    // Build and render final
    reRenderGraph(subjectName);

  } catch (err) {
    console.error(err);
    $('#graph-container').html(
      `<div class="p-2 text-center text-sm text-red-500">Error loading relationships: ${err}</div>`
    );
  }
}

// A function to ensure node exists
function addNodeIfNeeded(map, subject) {
  if (!map.has(subject)) {
    let bullet = allBullets.get(subject) || { bullet_point1:'', bullet_point2:'' };
    map.set(subject, bullet);
  }
}

// Deduplicate edges
function addEdge(edgesSet, edgesArray, from, to, label, category, color) {
  let key = `${from}||${to}||${category}||${label}`;
  if (edgesSet.has(key)) {
    return; // skip duplicates
  }
  edgesSet.add(key);
  edgesArray.push({ from, to, label, category, color });
}

// Partition
function partitionIndex(subj) {
  const h = murmurHash3.x86.hash32(subj);
  return h % NUM_PARTITIONS;
}

async function getZipText(zipObj, filename) {
  if (!zipObj.file(filename)) throw new Error(`Missing ${filename} in zip.`);
  return await zipObj.file(filename).async('string');
}

/***************************************
* DOT BUILDING / RENDERING
***************************************/
// We insert <br> every ~50 chars on word boundaries
function insertLineBreaks(str, maxLen=50) {
  if (!str) return '';
  const words = str.split(/\s+/);
  let lines = [];
  let current = '';

  for (let w of words) {
    if (!current) {
      current = w;
    } else if ((current + ' ' + w).length > maxLen) {
      lines.push(escapeHtml(current));
      current = w;
    } else {
      current += ' ' + w;
    }
  }
  if (current) lines.push(escapeHtml(current));
  return lines.join("<br>");
}

// Convert graph data to Cytoscape.js format
function buildCytoscapeElements(rootSubject, nodesMap, edges) {
  let elements = [];
  
  // Add nodes
  for (let [subj, bulletData] of nodesMap.entries()) {
    let isRoot = subj === rootSubject;
    
    // Create a label that includes the name and first bullet point
    let displayLabel = subj;
    let description = '';
    
    // Add first bullet point if available (truncated)
    if (bulletData.bullet_point1) {
      let bp1 = bulletData.bullet_point1;
      if (bp1.length > 80) {
        bp1 = bp1.substring(0, 77) + '...';
      }
      description = bp1;
    }
    
    elements.push({
      data: {
        id: subj,
        label: displayLabel,
        description: description,
        fullName: subj,
        bulletPoint1: bulletData.bullet_point1 || "",
        bulletPoint2: bulletData.bullet_point2 || "",
        isRoot: isRoot
      }
    });
  }
  
  // Add edges
  for (let e of edges) {
    // Truncate long edge labels for display
    let displayLabel = e.label;
    if (displayLabel.length > 40) {
      displayLabel = displayLabel.substring(0, 37) + '...';
    }
    
    // Generate more varied control points for better curve distribution
    // Use larger random offsets to create more distinct curves
    const randomOffset1 = Math.floor(Math.random() * 160) - 80;
    const randomOffset2 = Math.floor(Math.random() * 160) - 80;
    
    // Calculate edge angle to help with bundling
    const sourceNode = nodesMap.get(e.from);
    const targetNode = nodesMap.get(e.to);
    const isSourceRoot = e.from === rootSubject;
    const isTargetRoot = e.to === rootSubject;
    
    elements.push({
      data: {
        id: `${e.from}-${e.to}-${e.category}`,
        source: e.from,
        target: e.to,
        label: displayLabel,
        fullLabel: e.label,
        category: e.category,
        color: e.color,
        controlPointDistances: [randomOffset1, randomOffset2],
        isFromRoot: isSourceRoot,
        isToRoot: isTargetRoot
      }
    });
  }
  
  return elements;
}

// Initialize and render Cytoscape graph
function renderCytoscape(rootSubject, elements) {
  // Hide loading indicator
  $('#loading-indicator').hide();
  
  // Clear previous instance if exists
  if (window.cy) {
    try {
      window.cy.destroy();
    } catch (e) {
      console.warn("Could not destroy previous Cytoscape instance:", e);
      // Just continue, we'll create a new one
    }
  }
  
  // Create new Cytoscape instance
  try {
    window.cy = cytoscape({
      container: document.getElementById('cy'),
      elements: elements,
      style: [
        // Node styles
        {
          selector: 'node',
          style: {
            'background-color': '#F3F4F6',
            'border-color': '#94A3B8',
            'border-width': 1,
            'shape': 'rectangle',
            'width': function(ele) { return ele.data('label') ? 'label' : 180; },
            'height': function(ele) { return ele.data('label') ? 'label' : 60; },
            'padding': '15px', // Increased padding
            'text-wrap': 'wrap',
            'text-max-width': '180px', // Slightly reduced to help with layout
            'text-overflow-wrap': 'ellipsis', // Fixed deprecated property
            'text-valign': 'center',
            'text-halign': 'center',
            'font-family': 'Arial',
            'font-size': '13px',
            'label': function(ele) {
              const data = ele.data();
              if (data.description) {
                return data.label + '\n\n' + data.description;
              }
              return data.label;
            },
            'text-margin-y': 5,
            'text-wrap': 'wrap'
          }
        },
        // Root node style
        {
          selector: 'node[?isRoot]',
          style: {
            'border-color': '#2563EB',
            'border-width': 3,
            'background-color': '#EFF6FF',
            'font-weight': 'bold',
            'font-size': '15px',
            'z-index': 10 // Make sure root node is on top
          }
        },
        // Edge styles
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': 'data(color)',
            'target-arrow-color': 'data(color)',
            'target-arrow-shape': 'triangle',
            'curve-style': 'unbundled-bezier',
            'control-point-distances': function(ele) {
              // More pronounced curves to avoid overlaps
              const randomBase = 200 + (Math.random() * 100);
              return [randomBase * (Math.random() > 0.5 ? 1 : -1), randomBase * (Math.random() > 0.5 ? 1 : -1)];
            },
            'control-point-weights': [0.3, 0.7], // More asymmetric for better curve distribution
            'label': 'data(label)',
            'font-size': '11px',
            'text-background-color': 'white',
            'text-background-opacity': 0.9,
            'text-background-padding': '3px',
            'text-background-shape': 'rectangle',
            'font-family': 'Arial',
            'text-wrap': 'wrap',
            'text-max-width': '150px',
            'edge-text-rotation': 'autorotate'
          }
        },
        // Special style for edges from/to root
        {
          selector: 'edge[?isFromRoot], edge[?isToRoot]',
          style: {
            'width': 2.5, // Slightly thicker
            'line-style': 'solid',
            'curve-style': 'straight', // Use straight lines for root connections
            'control-point-distances': function(ele) {
              // No curve for root connections
              return [0, 0];
            }
          }
        }
      ],
      layout: {
        name: 'preset' // Start with preset to position root node
      }
    });
    
    // Calculate the center of the viewport
    const centerX = cy.width() / 2;
    const centerY = cy.height() / 2;
    
    // First position the root node at the exact center
    const rootNode = cy.nodes().filter(node => node.data('isRoot'));
    if (rootNode.length > 0) {
      rootNode.position({
        x: centerX,
        y: centerY
      });
      
      // Lock the root node position to prevent it from moving during layout
      rootNode.lock();
    }
    
    // Get all non-root nodes for circular distribution
    const nonRootNodes = cy.nodes().filter(node => !node.data('isRoot'));
    
    // Calculate optimal spacing based on node count
    const nodeCount = nonRootNodes.length;
    const minViewportDim = Math.min(cy.width(), cy.height());
    
    // Determine how many circles we need based on node count
    const nodesPerCircle = Math.max(8, Math.min(12, Math.floor(minViewportDim / 100)));
    const circleCount = Math.ceil(nodeCount / nodesPerCircle);
    
    // Distribute nodes across multiple concentric circles
    nonRootNodes.forEach((node, i) => {
      // Determine which circle this node belongs to
      const circleIndex = Math.floor(i / nodesPerCircle);
      const nodeIndexInCircle = i % nodesPerCircle;
      
      // Calculate radius for this circle (outer circles are larger)
      const baseRadius = minViewportDim * 0.45; // Increased from 0.4 to 0.45
      
      // Add slight randomness to radius to prevent perfect circles
      const radiusVariation = baseRadius * 0.15 * (Math.random() - 0.5);
      const radius = baseRadius * (1 + (circleIndex * 0.6)) + radiusVariation; // Increased spacing between circles
      
      // Calculate angle with offset for each circle to stagger nodes
      // Add slight angle variation to prevent perfect alignment
      const angleVariation = (Math.random() * 0.3 - 0.15) * (Math.PI / nodesPerCircle);
      const angleOffset = circleIndex * (Math.PI / nodesPerCircle);
      const angle = (2 * Math.PI * nodeIndexInCircle / nodesPerCircle) + angleOffset + angleVariation;
      
      // Set position
      node.position({
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
      
      // Store the original angle for this node to help with edge routing
      node.scratch('angle', angle);
    });
    
    // After layout completes, ensure the root node is still centered
    setTimeout(() => {
      try {
        // Force root node to center again
        if (rootNode.length > 0) {
          rootNode.unlock();
          rootNode.position({
            x: centerX,
            y: centerY
          });
          rootNode.lock(); // Lock it again
        }
        
        // Optimize edge routing to reduce overlaps
        // First, optimize positions of nodes connected to root to minimize crossings
        const rootConnectedNodes = cy.nodes().filter(node => {
          if (node.data('isRoot')) return false;
          return node.connectedEdges().some(edge => 
            edge.data('isFromRoot') || edge.data('isToRoot')
          );
        });
        
        // Sort root-connected nodes by their angle from center
        rootConnectedNodes.sort((a, b) => {
          const angleA = a.scratch('angle') || 0;
          const angleB = b.scratch('angle') || 0;
          return angleA - angleB;
        });
        
        // Adjust positions of root-connected nodes to be more evenly distributed
        const rootNodeCount = rootConnectedNodes.length;
        if (rootNodeCount > 0) {
          rootConnectedNodes.forEach((node, i) => {
            // Calculate a more evenly distributed angle
            const evenAngle = (2 * Math.PI * i / rootNodeCount);
            
            // Get current position and distance from center
            const pos = node.position();
            const dx = pos.x - centerX;
            const dy = pos.y - centerY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Maintain the same distance but adjust angle
            // Blend between current position and ideal position
            const blendFactor = 0.7; // 70% toward ideal position
            const idealX = centerX + currentDistance * Math.cos(evenAngle);
            const idealY = centerY + currentDistance * Math.sin(evenAngle);
            
            const newX = idealX * blendFactor + pos.x * (1 - blendFactor);
            const newY = idealY * blendFactor + pos.y * (1 - blendFactor);
            
            // Update position
            node.position({
              x: newX,
              y: newY
            });
            
            // Update scratch data
            node.scratch('angle', evenAngle);
          });
        }
        
        // Group edges by their general direction (in 16 sectors)
        const edgeGroups = {};
        cy.edges().forEach(edge => {
          const source = edge.source().position();
          const target = edge.target().position();
          
          // Skip edges to/from root as they're already handled with straight lines
          if (edge.data('isFromRoot') || edge.data('isToRoot')) {
            return;
          }
          
          // Calculate angle
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const angle = Math.atan2(dy, dx);
          
          // Convert to sector (0-15, dividing the circle into 16 parts for finer control)
          const sector = Math.floor(((angle + Math.PI) / (2 * Math.PI) * 16) % 16);
          
          if (!edgeGroups[sector]) {
            edgeGroups[sector] = [];
          }
          edgeGroups[sector].push(edge);
        });
        
        // For each sector, adjust control points to reduce overlaps
        Object.keys(edgeGroups).forEach(sector => {
          const edges = edgeGroups[sector];
          const sectorAngle = (parseInt(sector) / 16) * 2 * Math.PI - Math.PI;
          
          // Sort edges by length
          edges.sort((a, b) => {
            const aLength = getEdgeLength(a);
            const bLength = getEdgeLength(b);
            return aLength - bLength;
          });
          
          // Adjust control points based on position in group
          edges.forEach((edge, i) => {
            const baseDistance = 200 + (i * 40); // Increased distance for each edge
            const perpDistance = 100 + (i % 3) * 80; // Increased perpendicular offset
            
            // Calculate perpendicular vector
            const perpX = Math.sin(sectorAngle);
            const perpY = -Math.cos(sectorAngle);
            
            // Set control points
            const cp1 = baseDistance * (i % 2 === 0 ? 1 : -1);
            const cp2 = baseDistance * (i % 2 === 0 ? -1 : 1);
            
            edge.style({
              'control-point-distances': [cp1, cp2],
              'control-point-weights': [0.3, 0.7]
            });
          });
        });
        
        // Function to calculate edge length
        function getEdgeLength(edge) {
          const source = edge.source().position();
          const target = edge.target().position();
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Improved overlap prevention algorithm
        // First, get accurate node dimensions including labels
        const nodeData = [];
        cy.nodes().forEach(node => {
          const bb = node.boundingBox({includeLabels: true, includeOverlays: true});
          const pos = node.position();
          nodeData.push({
            node: node,
            x: pos.x,
            y: pos.y,
            width: bb.w,
            height: bb.h,
            isRoot: node.data('isRoot')
          });
        });
        
        // Run multiple passes of overlap removal with increasing strength
        for (let pass = 0; pass < 4; pass++) { // Increased from 3 to 4 passes
          const strength = 0.3 + (pass * 0.3); // Increase force with each pass
          
          // Multiple iterations per pass
          for (let iter = 0; iter < 50; iter++) {
            let moved = false;
            
            // Check each pair of nodes for overlap
            for (let i = 0; i < nodeData.length; i++) {
              if (nodeData[i].isRoot) continue; // Skip root node
              
              let totalForceX = 0;
              let totalForceY = 0;
              let forcesApplied = 0;
              
              for (let j = 0; j < nodeData.length; j++) {
                if (i === j) continue;
                
                const nodeA = nodeData[i];
                const nodeB = nodeData[j];
                
                // Calculate distance between node centers
                const dx = nodeB.x - nodeA.x;
                const dy = nodeB.y - nodeA.y;
                const distanceSquared = dx * dx + dy * dy;
                
                // Calculate minimum required distance to avoid overlap (with padding)
                const minDistX = (nodeA.width + nodeB.width) / 2 + 70; // Increased from 50 to 70px extra padding
                const minDistY = (nodeA.height + nodeB.height) / 2 + 70; // Increased from 50 to 70px
                
                // Check if nodes overlap or are too close
                const overlapX = minDistX * minDistX > distanceSquared * (dx * dx) / distanceSquared;
                const overlapY = minDistY * minDistY > distanceSquared * (dy * dy) / distanceSquared;
                
                if (overlapX || overlapY || distanceSquared < Math.pow(Math.max(minDistX, minDistY), 2)) {
                  // Calculate repulsion force
                  const distance = Math.sqrt(distanceSquared) || 0.1; // Avoid division by zero
                  const minDist = Math.sqrt(minDistX * minDistX + minDistY * minDistY);
                  const force = strength * (minDist - distance) / distance;
                  
                  // Apply force vector
                  totalForceX -= (dx / distance) * force;
                  totalForceY -= (dy / distance) * force;
                  forcesApplied++;
                  
                  moved = true;
                }
                
                // Add repulsion from root node (stronger for closer nodes)
                if (nodeB.isRoot) {
                  const rootRepulsionStrength = 0.5;
                  const rootDistance = Math.sqrt(distanceSquared) || 0.1;
                  const rootForce = rootRepulsionStrength * (200 / rootDistance);
                  
                  totalForceX -= (dx / rootDistance) * rootForce;
                  totalForceY -= (dy / rootDistance) * rootForce;
                  forcesApplied++;
                }
              }
              
              // Apply accumulated forces
              if (forcesApplied > 0) {
                // Limit maximum movement per iteration
                const maxMove = 20;
                const forceMagnitude = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
                
                if (forceMagnitude > maxMove) {
                  const scale = maxMove / forceMagnitude;
                  totalForceX *= scale;
                  totalForceY *= scale;
                }
                
                // Update node position
                nodeData[i].x += totalForceX;
                nodeData[i].y += totalForceY;
                nodeData[i].node.position({
                  x: nodeData[i].x,
                  y: nodeData[i].y
                });
              }
            }
            
            if (!moved) break; // Stop if no nodes were moved
          }
        }
        
        // Apply a radial constraint to maintain circular distribution
        // but with less weight than the overlap prevention
        const idealRadius = Math.min(cy.width(), cy.height()) * 0.55; // Increased from 0.5 to 0.55
        
        // First, handle nodes connected to root to ensure they're well-distributed
        const rootConnectedData = nodeData.filter(data => {
          if (data.isRoot) return false;
          return data.node.connectedEdges().some(edge => 
            edge.data('isFromRoot') || edge.data('isToRoot')
          );
        });
        
        // Sort by angle for more even distribution
        rootConnectedData.sort((a, b) => {
          const angleA = Math.atan2(a.y - centerY, a.x - centerX);
          const angleB = Math.atan2(b.y - centerY, b.x - centerX);
          return angleA - angleB;
        });
        
        // Adjust positions to be more evenly distributed
        const rootConnCount = rootConnectedData.length;
        if (rootConnCount > 0) {
          rootConnectedData.forEach((data, i) => {
            // Calculate ideal angle and position
            const idealAngle = (2 * Math.PI * i / rootConnCount);
            const idealX = centerX + idealRadius * Math.cos(idealAngle);
            const idealY = centerY + idealRadius * Math.sin(idealAngle);
            
            // Strong blend toward ideal position (80%)
            const blendFactor = 0.8;
            const newX = idealX * blendFactor + data.x * (1 - blendFactor);
            const newY = idealY * blendFactor + data.y * (1 - blendFactor);
            
            // Update position
            data.node.position({
              x: newX,
              y: newY
            });
            
            // Update stored position
            data.x = newX;
            data.y = newY;
          });
        }
        
        // Then handle remaining nodes with a weaker circular constraint
        nodeData.forEach(data => {
          if (data.isRoot) return; // Skip root node
          
          // Skip nodes that are connected to root (already handled)
          if (data.node.connectedEdges().some(edge => 
            edge.data('isFromRoot') || edge.data('isToRoot')
          )) {
            return;
          }
          
          // Calculate current angle and distance from center
          const dx = data.x - centerX;
          const dy = data.y - centerY;
          const angle = Math.atan2(dy, dx);
          const currentDistance = Math.sqrt(dx * dx + dy * dy);
          
          // Calculate ideal position on circle with some randomness
          // This prevents nodes from forming perfect circles which can cause edge overlaps
          const radiusVariation = idealRadius * 0.15 * (Math.random() - 0.5);
          const idealRadius2 = idealRadius + radiusVariation;
          
          const idealX = centerX + idealRadius2 * Math.cos(angle);
          const idealY = centerY + idealRadius2 * Math.sin(angle);
          
          // Blend current position with ideal circular position (20% circular, 80% current)
          // Reduced from 25% to 20% to prioritize overlap prevention even more
          const blendFactor = 0.2;
          const newX = idealX * blendFactor + data.x * (1 - blendFactor);
          const newY = idealY * blendFactor + data.y * (1 - blendFactor);
          
          // Update node position
          data.node.position({
            x: newX,
            y: newY
          });
          
          // Update stored position
          data.x = newX;
          data.y = newY;
        });
        
        // Final overlap check with stronger forces
        for (let iter = 0; iter < 40; iter++) { // Increased from 30 to 40 iterations
          let moved = false;
          
          for (let i = 0; i < nodeData.length; i++) {
            if (nodeData[i].isRoot) continue;
            
            for (let j = 0; j < nodeData.length; j++) {
              if (i === j) continue;
              
              const nodeA = nodeData[i];
              const nodeB = nodeData[j];
              
              // Skip if one node is far from the other
              const dx = nodeB.x - nodeA.x;
              const dy = nodeB.y - nodeA.y;
              const distSquared = dx * dx + dy * dy;
              
              // Quick distance check before detailed calculation
              const maxDimSum = nodeA.width + nodeA.height + nodeB.width + nodeB.height;
              if (distSquared > maxDimSum * maxDimSum / 4) continue;
              
              // Calculate minimum required distance to avoid overlap (with padding)
              const minDistX = (nodeA.width + nodeB.width) / 2 + 80; // Increased from 60 to 80px
              const minDistY = (nodeA.height + nodeB.height) / 2 + 80; // Increased from 60 to 80px
              
              // Check if nodes overlap
              if (Math.abs(dx) < minDistX && Math.abs(dy) < minDistY) {
                // Calculate movement direction
                const distance = Math.sqrt(distSquared) || 0.1;
                const overlapAmount = Math.sqrt(minDistX * minDistX + minDistY * minDistY) - distance;
                
                if (overlapAmount > 0) {
                  // Move nodeA away from nodeB
                  const moveX = (dx / distance) * overlapAmount * 0.7; // Increased from 0.6 to 0.7
                  const moveY = (dy / distance) * overlapAmount * 0.7; // Increased from 0.6 to 0.7
                  
                  nodeData[i].x -= moveX;
                  nodeData[i].y -= moveY;
                  nodeData[i].node.position({
                    x: nodeData[i].x,
                    y: nodeData[i].y
                  });
                  
                  moved = true;
                }
              }
            }
          }
          
          if (!moved) break;
        }
        
        // Ensure all nodes are visible by fitting to the viewport with padding
        cy.fit(cy.elements(), 90); // Increased padding from 70 to 90
        
        // Make sure we're not too zoomed in
        const maxZoomLevel = 0.5; // Lower value = more zoomed out
        const currentZoom = cy.zoom();
        
        if (currentZoom > maxZoomLevel) {
          cy.zoom({
            level: maxZoomLevel,
            renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
          });
        }
        
        // Final check to ensure root is centered
        setTimeout(() => {
          rootNode.unlock();
          rootNode.position({
            x: centerX,
            y: centerY
          });
          cy.center(rootNode);
        }, 100);
        
      } catch (err) {
        console.error("Error in layout processing:", err);
      }
      
      // Add event listeners for tooltips
      cy.on('mouseover', 'node', function(e) {
        const node = e.target;
        const data = node.data();
        
        // Only show tooltip if there's a second bullet point that's not shown in the node
        if (data.bulletPoint2) {
          const tooltip = $('.cy-tooltip');
          let content = `<strong>Additional info:</strong><br><br>${escapeHtml(data.bulletPoint2)}`;
          
          tooltip.html(content);
          
          const renderedPosition = node.renderedPosition();
          const containerOffset = $('#cy').offset();
          
          tooltip.css({
            'left': containerOffset.left + renderedPosition.x + 10,
            'top': containerOffset.top + renderedPosition.y - 10,
            'opacity': 1
          });
        }
      });
      
      cy.on('mouseover', 'edge', function(e) {
        const edge = e.target;
        const data = edge.data();
        
        if (data.fullLabel && data.fullLabel !== data.label) {
          const tooltip = $('.cy-tooltip');
          tooltip.html(`<strong>${escapeHtml(data.fullLabel)}</strong>`);
          
          const midpoint = edge.midpoint();
          const containerOffset = $('#cy').offset();
          
          tooltip.css({
            'left': containerOffset.left + midpoint.x,
            'top': containerOffset.top + midpoint.y,
            'opacity': 1
          });
        }
      });
      
      cy.on('mouseout', 'node, edge', function() {
        $('.cy-tooltip').css('opacity', 0);
      });
      
      // Show download button
      $('#downloadBtn').show();
      
      // Add event listeners for control buttons
      $('#zoom-in').off('click').on('click', function() {
        cy.zoom({
          level: cy.zoom() * 1.2,
          renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
        });
      });
      
      $('#zoom-out').off('click').on('click', function() {
        cy.zoom({
          level: cy.zoom() * 0.8,
          renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
        });
      });
      
      $('#reset-view').off('click').on('click', function() {
        cy.fit();
        cy.center();
      });
      
      // Enable touch gestures for mobile
      cy.userZoomingEnabled(true);
      cy.userPanningEnabled(true);
      cy.boxSelectionEnabled(false);
    }, 100);
    
  } catch (err) {
    console.error("Error initializing Cytoscape:", err);
    $('#graph-container').html(
      `<div class="p-2 text-center text-sm text-red-500">Error rendering graph: ${err.message}</div>`
    );
  }
}

// Re-render the graph with filtered edges
function reRenderGraph(rootSubject) {
  let activeEdges = globalAllEdges.filter(e => globalActiveCategories.has(e.category));
  let elements = buildCytoscapeElements(rootSubject, globalNodesMap, activeEdges);
  renderCytoscape(rootSubject, elements);
}

/***************************************
* LEGEND & CATEGORY TOGGLING
***************************************/
function renderLegend(categories) {
  let html = '';
  categories.sort(); // optional: sort them alphabetically
  for (let c of categories) {
    let color = categoryColors[c] || categoryColors["UNKNOWN"];
    html += `<div class="legend-item" style="background-color: ${color};" data-cat="${c}">${c}</div>`;
  }
  $('#legend').html(html);

  // Attach click handler
  $('#legend .legend-item').on('click', function() {
    let cat = $(this).data('cat');
    toggleCategory(cat);
    $(this).toggleClass('disabled', !globalActiveCategories.has(cat));
  });
}

// Toggle a category in/out of the active set
function toggleCategory(cat) {
  if (globalActiveCategories.has(cat)) {
    globalActiveCategories.delete(cat);
  } else {
    globalActiveCategories.add(cat);
  }
  // re-render
  let rootName = $('#graphTitle').text().trim();
  reRenderGraph(rootName);
}


/***************************************
* DOWNLOAD PNG
***************************************/
$('#downloadBtn').on('click', function() {
  if (!window.cy) {
    alert('No graph to download');
    return;
  }
  
  try {
    // Create a PNG image
    const png64 = window.cy.png({
      output: 'blob',
      scale: 2, // Higher resolution
      bg: 'white',
      full: true
    });
    
    // Create download link
    const url = URL.createObjectURL(png64);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'relation_graph.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Error generating PNG:", err);
    alert("Could not generate PNG. Please try again.");
  }
});


/***************************************
* HELPER
***************************************/
function escapeHtml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}
</script>